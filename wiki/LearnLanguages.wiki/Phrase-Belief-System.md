To me, a PhraseBelief is an odd-sounding thing to store in a database. 

A belief about a phrase? Why not store memory strength trace? That would tell you how strong of a memory trace you have for a phrase, right? Well, we don't need to jump to conclusions like "memory trace strength". Instead, we create a system that would allow us to record something like that in the future, but the main thing we want to do is record _something_ about a phrase, and that something has some common features. The important features of that common structure is what I'm trying to capture.

My initial usage of this is as follows: I review a phrase in some fashion. I review this phrase using a DefaultManualPhraseReviewerQA or a DefaultTimedPhraseReviewerQA. The Id's of these constructs are generated at design-time. I also have a PhraseReviewedRecorder that generates one of these beliefs and stores it. 

This is done through a SAGA-esque, long-running, decoupled, asynchronous process. It's a relatively complex event-driven system. It records feedback that is received after the reviewer has presented the item to the user. Say the user presses "Most", as in, the user knows "most" of the phrase being reviewed (or in the brain-trace paradigm, the user has a relatively strong brain trace at that particular point in time). The recorder records this as a belief about a Phrase, currently set to 0.75 in this case, and stores this belief in the DB. It also has a Text associated with it. It builds up a query string with other properties about the belief. (Strength is separated out of this, because it is the most important aspect.) Right now, the text includes duration in milliseconds, the line id of the review, and the line number.

To recap thus far, the PhraseBelief has a PhraseId, a ReviewMethodId (VM/View that presented the phrase), a Strength (0.75, interpreted feedback from "most"), and a Text (query string with additional information). Now, we just need to set the BelieverId.

**However**, the UserId is **NOT** the BelieverId. 

The user's belief is in his own database in his head, the one doing the believing is the recorder. This is **PARAMOUNT** to understanding the foundations of the treatment of data in my architecture. We are including the source of the belief in the database, but we can never have a user's direct internal knowledge representation inside of the DB. We can only (try to) build more and more accurate guesses at approximately what our current implementation of programming believes. In this case, the recorder believes that the user has done something with a phrase with a PhraseId, using a certain review method with a ReviewId. That something lasted for a certain duration, and after that duration, the user pressed something that the recorder interpreted as 0.75.

You might say that if we recorded that the user clicked "Most", and store this as say a 2 (for its index in an enumeration of 0=none, 1=some, 2=most, 3=all), then we would have a definitive recording of history, that we have the knowledge of it being a 2. And in a more rigid way of thinking you would be correct. But eventually, we turn this enumeration into a guess, like a rating system. 3.5 stars, that sort of thing. We recognize it's an approximation. I'm simply normalizing this, and including the normalization in the recorder. Later on, if we so choose, we can certainly introduce a recorder that listens for the same events (maybe a meta-recorder that listens to this recorder and converts its 0.75 to 2) and stores the information it wants. That's perfectly fine, and that is one of the reasons why I'm designing it this way: to be able to add additional recorders at will, that could even examine past history recorders beliefs - meta-recording.

In fact, with this thought of this meta-recorder, this process can now take on a larger scope, and if you want to delve into the theory, can even lead you to argue how the first recorder didn't really "record" the actual event, that sums up somewhat to the following: It formed a belief in its database, and we have a high-degree of confidence in our ability to retrieve the same value out as it put in. So much confidence, that we consider it to be the same. This is along the lines of understanding 1 != 1, but that is for another time.

Back to the meta-recorder concept, and looking at a "larger" SAGA, consider we introduce another listener to this flow of events (published in the History.Publish event aggregator). Say we have a recorder set up that listens to other recorders' events. Say it is listening for PhraseBeliefs, published by a certain Believer, involving a particular PhraseId. It then looks up other PhraseBeliefs involving that PhraseId, formed by possibly other believers. It then analyzes those beliefs, and if it decides something, it can either do something itself, and/or then it can publish its own event! This is truly an aggregating event system!

An example of this would be a ForgotThisPhrase event. It examines beliefs, checks for durations, timestamps, as well as examining any other data it wants (say it analyzes all phrase belief activity to see how often the user is using the program), and then it publishes a belief about the phrase. This belief is a strong advice to put the phrase on a particular regiment for review, say that the phrase needs extra care, or less care. For this step in the overall process, check out the [Advice System](https://github.com/bill-mybiz/LearnLanguages/wiki/Advice-System).

### Related
* [Advice System](https://github.com/bill-mybiz/LearnLanguages/wiki/Advice-System)

### Notes
* I wanted to just have a Belief, without the PhraseId included in the design, but I've decided to create this first, then I'll move on to other beliefs on a use case basis. The only beliefs I care about at first, to get the process working somewhat, are the beliefs about phrases.

So, opportunities are endless with this open-ended, aggregating event design pattern. 